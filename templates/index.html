<!DOCTYPE html>
<html lang="zh-TW" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StockView Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { background-color: #1a1a1a; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; }
        .loader { 
            border: 3px solid #333; 
            border-top: 3px solid #3498db; 
            border-radius: 50%; 
            width: 24px; 
            height: 24px; 
            min-width: 24px;
            min-height: 24px;
            flex-shrink: 0;
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        [v-cloak] { display: none; }
        .stock-item.active { background-color: #2563eb; color: white; }
        .chart-section { border-top: 1px solid #2a2e39; }
        .chart-label { 
            position: absolute; 
            left: 8px; 
            top: 4px; 
            z-index: 10; 
            font-size: 11px; 
            color: #888; 
            background: rgba(19, 23, 34, 0.8);
            padding: 2px 6px;
            border-radius: 3px;
        }
        .debug-panel {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 400px;
            max-height: 200px;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            z-index: 9999;
            border-top: 1px solid #333;
            border-left: 1px solid #333;
        }
        .debug-panel .log-entry { margin: 2px 0; }
        .debug-panel .log-error { color: #f66; }
        .debug-panel .log-warn { color: #ff0; }
        .debug-panel .log-success { color: #0f0; }
        .debug-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 10000;
            background: #333;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
    </style>
</head>
<body class="h-screen w-screen flex">
    <div id="app" class="flex w-full h-full">
        <!-- Sidebar -->
        <div :class="['bg-neutral-900 border-r border-neutral-800 flex flex-col z-20 h-full flex-shrink-0', isSidebarOpen ? 'w-80' : 'w-0 overflow-hidden']">
            <div class="p-4 border-b border-neutral-800">
                <h1 class="text-xl font-bold text-blue-400">StockView</h1>
                <div class="text-xs text-gray-500 mt-1">v0.2 - Crosshair Sync + Right Lock</div>
            </div>
            <div class="flex border-b border-neutral-800">
                <button @click="currentMarket = 'TW'" :class="['flex-1 py-3', currentMarket === 'TW' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-400']">TW Âè∞ËÇ°</button>
                <button @click="currentMarket = 'US'" :class="['flex-1 py-3', currentMarket === 'US' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-400']">US ÁæéËÇ°</button>
            </div>
            <div class="flex-1 overflow-y-auto">
                <div v-for="stock in filteredStocks" :key="stock.symbol" @click="selectStock(stock)" :class="['p-3 mx-2 mb-1 rounded cursor-pointer flex justify-between', currentStock?.symbol === stock.symbol ? 'stock-item active' : 'hover:bg-neutral-800 text-gray-300']">
                    <div><div class="font-bold text-sm">{{ stock.symbol }}</div><div class="text-xs opacity-70">{{ stock.name }}</div></div>
                </div>
            </div>
        </div>
        <!-- Chart Area -->
        <div class="flex-1 flex flex-col h-full relative overflow-hidden" style="background-color: #0a0e17;">
            
            <!-- Compact Header -->
            <div class="border-b px-4 py-2 flex-shrink-0" style="background-color: #1a2332; border-color: #2a3a4a;">
                <!-- Top Row: Name, Price, OHLCV combined -->
                <div class="flex flex-col gap-1">
                    <!-- Row 1: Basic Info & Price -->
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <button @click="isSidebarOpen = !isSidebarOpen" class="text-gray-400 hover:text-white">
                                <i class="fas fa-bars text-lg"></i>
                            </button>
                            <div v-if="currentStock" class="flex items-center gap-2">
                                <span class="text-white text-lg font-bold">{{ currentStock.name }}</span>
                                <span class="text-gray-400 text-sm">{{ currentStock.symbol }}</span>
                            </div>
                        </div>
                        
                        <div v-if="currentCandle" class="flex items-center gap-4">
                            <div class="text-2xl font-bold" :class="priceChange >= 0 ? 'text-red-500' : 'text-green-500'">
                                {{ currentCandle.close.toFixed(2) }}
                            </div>
                            <div class="flex flex-col items-end text-xs">
                                <span :class="priceChange >= 0 ? 'text-red-500' : 'text-green-500'">
                                    {{ priceChange >= 0 ? '‚ñ≤' : '‚ñº' }} {{ Math.abs(priceChange).toFixed(2) }}
                                </span>
                                <span :class="priceChange >= 0 ? 'text-red-500' : 'text-green-500'">
                                    {{ priceChangePercent.toFixed(2) }}%
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Row 2: OHLCV (Horizontal) -->
                    <div v-if="currentCandle" class="flex items-center gap-4 text-xs text-gray-300 font-mono bg-[#0f1419] p-1 rounded" style="background-color: #0f1419;">
                        <div><span class="text-gray-500">D:</span> {{ currentCandle.time }}</div>
                        <div><span class="text-gray-500">O:</span> <span class="text-white">{{ currentCandle.open.toFixed(2) }}</span></div>
                        <div><span class="text-gray-500">H:</span> <span class="text-red-400">{{ currentCandle.high.toFixed(2) }}</span></div>
                        <div><span class="text-gray-500">L:</span> <span class="text-green-400">{{ currentCandle.low.toFixed(2) }}</span></div>
                        <div><span class="text-gray-500">C:</span> <span :class="currentCandle.close >= currentCandle.open ? 'text-red-400' : 'text-green-400'">{{ currentCandle.close.toFixed(2) }}</span></div>
                        <div><span class="text-gray-500">V:</span> <span class="text-yellow-400">{{ formatVolume(currentCandle.volume) }}</span></div>
                    </div>
                    
                    <!-- Row 3: MA Values -->
                    <div v-if="currentMAs.length > 0" class="flex flex-wrap gap-3 text-xs">
                        <div v-for="(ma, i) in currentMAs" :key="i" class="flex items-center gap-1">
                            <span :style="{ color: maColors[i] }">MA{{ maPeriods[i] }}:</span>
                            <span class="text-white font-mono">{{ ma.value?.toFixed(2) || '--' }}</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Charts Container (Scrollable) -->
            <div class="flex-1 overflow-y-auto" ref="chartsScrollContainer" style="background-color: #0a0e17;">
                <!-- Main Candlestick Chart -->
                <div class="relative" style="height: 50%;">
                    <div ref="mainChartContainer" class="absolute inset-0"></div>
                </div>
                <!-- RSI Chart -->
                <div class="relative border-t" style="height: 12.5%; border-color: #1a2332;">
                    <div ref="rsiChartContainer" class="absolute inset-0"></div>
                </div>
                <!-- KD Chart -->
                <div class="relative border-t" style="height: 12.5%; border-color: #1a2332;">
                    <div ref="kdChartContainer" class="absolute inset-0"></div>
                </div>
                <!-- BIAS Chart -->
                <div class="relative border-t" style="height: 12.5%; border-color: #1a2332;">
                    <div ref="biasChartContainer" class="absolute inset-0"></div>
                </div>
                <!-- MACD Chart -->
                <div class="relative border-t" style="height: 12.5%; border-color: #1a2332;">
                    <div ref="macdChartContainer" class="absolute inset-0"></div>
                </div>
            </div>
            <!-- Error Overlay -->
            <div v-if="error" class="absolute inset-0 flex items-center justify-center bg-black/80 text-red-400 z-50">{{ error }}</div>
        </div>
        
        <!-- Loading Overlay (Centered) -->
        <div v-if="loading" class="absolute inset-0 flex flex-col items-center justify-center z-50" style="background-color: rgba(0,0,0,0.5);">
            <div class="loader mb-2"></div>
            <div class="text-blue-400 font-bold">ËºâÂÖ•‰∏≠...</div>
        </div>

        <!-- Debug Panel -->
        <button class="debug-toggle" @click="showDebug = !showDebug">{{ showDebug ? 'Èö±Ëóè' : 'üìã' }} Log</button>
        <div v-if="showDebug" class="debug-panel" ref="debugPanel">
            <div v-for="(log, i) in debugLogs" :key="i" :class="['log-entry', log.type]">
                {{ log.time }} {{ log.msg }}
            </div>
        </div>
    </div>
    <script>
        console.log('DEBUG: StockView Pro v0.2 loading...');
        
        // ============================================
        // v0.2 Core: Chart State Manager
        // Rule 1: Global Crosshair Synchronization
        // Rule 2: Right Edge Lock - No Whitespace
        // ============================================
        const createChartStateManager = () => ({
            state: {
                crosshair: { index: null, timestamp: null, isLocked: false },
                viewport: { 
                    candleWidth: 10, 
                    visibleCount: 150, 
                    rightOffset: 0,
                    dataRange: { start: 0, end: 0 }
                }
            },
            data: [],
            subscribers: [],
            
            setData(data) {
                this.data = data;
                this.enforceRightAlignment();
            },
            
            // Rule 1: Set crosshair index and notify all charts
            setCrosshairIndex(index) {
                if (index < 0 || index >= this.data.length) return;
                this.state.crosshair.index = index;
                this.state.crosshair.timestamp = this.data[index]?.time;
                this.state.crosshair.isLocked = true;
                this.notify('crosshair:move', { index, timestamp: this.state.crosshair.timestamp });
            },
            
            clearCrosshair() {
                this.state.crosshair.index = null;
                this.state.crosshair.isLocked = false;
                this.notify('crosshair:clear', {});
            },
            
            // Rule 2: Enforce right alignment
            enforceRightAlignment() {
                if (!this.data.length) return;
                const endIndex = this.data.length - 1;
                this.state.viewport.dataRange.end = endIndex;
                this.state.viewport.dataRange.start = Math.max(0, endIndex - this.state.viewport.visibleCount + 1);
                this.state.viewport.rightOffset = 0;
                this.notify('viewport:align', this.state.viewport);
            },
            
            // Rule 2: Zoom with right anchor
            zoom(factor, minWidth = 2, maxWidth = 50) {
                const newWidth = Math.max(minWidth, Math.min(this.state.viewport.candleWidth * factor, maxWidth));
                this.state.viewport.candleWidth = newWidth;
                this.enforceRightAlignment();
                this.notify('viewport:zoom', this.state.viewport);
            },
            
            subscribe(callback) {
                this.subscribers.push(callback);
            },
            
            notify(event, payload) {
                this.subscribers.forEach(cb => cb(event, payload));
            }
        });
        
        // Global state manager instance
        const chartState = createChartStateManager();
        
        // Define constants injected by backend
        const MA_COLORS = __MA_COLORS__;
        const MA_PERIODS = __MA_PERIODS__;
        const STOCK_LIST = __STOCK_LIST__;
        
        const { createApp, ref, computed, onMounted, nextTick } = Vue;
        console.log('DEBUG: Destructuring Vue OK');
        createApp({
            setup() {
                console.log('DEBUG: Vue setup() started');
                const isSidebarOpen = ref(window.innerWidth > 768);
                const currentMarket = ref('TW');
                const currentStock = ref(STOCK_LIST[0]);
                const loading = ref(false);
                const error = ref(null);
                const showDebug = ref(false);
                const debugLogs = ref([]);
                const debugPanel = ref(null);
                
                // Expose constants to template
                const maColors = ref(MA_COLORS);
                const maPeriods = ref(MA_PERIODS);

                
                // Yuanta-style new reactive variables
                const currentCandle = ref(null);
                const currentMAs = ref([]);
                const priceChange = ref(0);
                const priceChangePercent = ref(0);
                
                // Format volume (convert to K/M)
                const formatVolume = (vol) => {
                    if (!vol) return '--';
                    if (vol >= 1000000) return (vol / 1000000).toFixed(2) + 'M';
                    if (vol >= 1000) return (vol / 1000).toFixed(0) + 'K';
                    return vol.toString();
                };
                
                const addLog = (msg, type = '') => {
                    const now = new Date();
                    const time = now.toLocaleTimeString('zh-TW', {hour12: false}) + '.' + String(now.getMilliseconds()).padStart(3, '0');
                    debugLogs.value.push({ time, msg, type });
                    if (debugLogs.value.length > 50) debugLogs.value.shift();
                    // Auto scroll
                    nextTick(() => {
                        if (debugPanel.value) debugPanel.value.scrollTop = debugPanel.value.scrollHeight;
                    });
                    console.log(`[${time}] ${msg}`);
                };
                
                // Chart containers
                const chartsScrollContainer = ref(null);
                const mainChartContainer = ref(null);
                const rsiChartContainer = ref(null);
                const kdChartContainer = ref(null);
                const biasChartContainer = ref(null);
                const macdChartContainer = ref(null);
                
                // Chart instances
                let mainChart = null, candleSeries = null, maLines = [];
                let rsiChart = null, rsiLines = [];
                let kdChart = null, kLine = null, dLine = null;
                let biasChart = null, biasLines = [];
                let macdChart = null, difLine = null, deaLine = null, histSeries = null;
                
                let abortController = null;

                const filteredStocks = computed(() => STOCK_LIST.filter(s => s.market === currentMarket.value));

                const chartOptions = (container) => ({
                    layout: { background: { type: 'solid', color: '#131722' }, textColor: '#d1d4dc' },
                    grid: { vertLines: { color: '#2B2B43' }, horzLines: { color: '#2B2B43' } },
                    timeScale: { borderColor: '#485c7b', timeVisible: true, visible: true },
                    rightPriceScale: { borderColor: '#485c7b' },
                    crosshair: { mode: LightweightCharts.CrosshairMode.Normal }
                });

                const initCharts = () => {
                    // Main chart with candlesticks
                    mainChart = LightweightCharts.createChart(mainChartContainer.value, chartOptions());
                    // Taiwan Style: Red for Up, Green for Down
                    candleSeries = mainChart.addCandlestickSeries({
                        upColor: '#EF5350', 
                        downColor: '#26A69A',
                        borderUpColor: '#EF5350', 
                        borderDownColor: '#26A69A', 
                        wickUpColor: '#EF5350', 
                        wickDownColor: '#26A69A'
                    });
                    
                    // RSI chart
                    rsiChart = LightweightCharts.createChart(rsiChartContainer.value, {
                        ...chartOptions(),
                        rightPriceScale: { scaleMargins: { top: 0.1, bottom: 0.1 } }
                    });
                    
                    // KD chart
                    kdChart = LightweightCharts.createChart(kdChartContainer.value, {
                        ...chartOptions(),
                        rightPriceScale: { scaleMargins: { top: 0.1, bottom: 0.1 } }
                    });
                    
                    // BIAS chart
                    biasChart = LightweightCharts.createChart(biasChartContainer.value, {
                        ...chartOptions(),
                        rightPriceScale: { scaleMargins: { top: 0.2, bottom: 0.2 } }
                    });
                    
                    // MACD chart
                    macdChart = LightweightCharts.createChart(macdChartContainer.value, {
                        ...chartOptions(),
                        rightPriceScale: { scaleMargins: { top: 0.2, bottom: 0.2 } }
                    });
                    
                    // Crosshair Move Handler - Yuanta Style
                    mainChart.subscribeCrosshairMove(param => {
                        if (!param.time) {
                            return;
                        }
                        
                        const candleData = param.seriesData.get(candleSeries);
                        if (candleData) {
                            currentCandle.value = candleData;
                            priceChange.value = candleData.close - candleData.open;
                            priceChangePercent.value = (priceChange.value / candleData.open) * 100;
                            
                            // Update MA values
                            const mas = [];
                            maLines.forEach((line, i) => {
                                const val = param.seriesData.get(line);
                                if (val !== undefined) {
                                    mas.push({ period: MA_PERIODS[i], value: val.value });
                                }
                            });
                            currentMAs.value = mas;
                        }
                    });
                    
                    // Sync all charts' time scales
                    const charts = [mainChart, rsiChart, kdChart, biasChart, macdChart];
                    charts.forEach(chart => {
                        chart.timeScale().subscribeVisibleLogicalRangeChange(range => {
                            if (range) {
                                charts.forEach(c => {
                                    if (c !== chart) {
                                        c.timeScale().setVisibleLogicalRange(range);
                                    }
                                });
                            }
                        });
                    });
                    
                    // Resize observer
                    const resizeObserver = new ResizeObserver(() => {
                        [
                            [mainChartContainer, mainChart],
                            [rsiChartContainer, rsiChart],
                            [kdChartContainer, kdChart],
                            [biasChartContainer, biasChart],
                            [macdChartContainer, macdChart]
                        ].forEach(([container, chart]) => {
                            if (container.value && chart) {
                                chart.applyOptions({ 
                                    width: container.value.clientWidth, 
                                    height: container.value.clientHeight 
                                });
                            }
                        });
                    });
                    
                    [mainChartContainer, rsiChartContainer, kdChartContainer, biasChartContainer, macdChartContainer]
                        .forEach(c => { if (c.value) resizeObserver.observe(c.value); });
                };

                const loadStockData = async (stock) => {
                    const reqId = Math.random().toString(36).substring(7);
                    addLog(`[${reqId}] üîµ SELECT: ${stock.symbol}`, 'log-success');
                    
                    if (abortController) {
                        addLog(`[${reqId}] ‚ö†Ô∏è Aborting previous request`, 'log-warn');
                        abortController.abort();
                    }
                    abortController = new AbortController();
                    const signal = abortController.signal;

                    loading.value = true; error.value = null;
                    const fetchStart = performance.now();
                    
                    try {
                        addLog(`[${reqId}] üì° FETCH: /api/stock/${stock.symbol}`);
                        // Add timestamp to prevent caching
                        const res = await fetch(`/api/stock/${stock.symbol}?t=${Date.now()}`, { signal });
                        const fetchEnd = performance.now();
                        addLog(`[${reqId}] ‚úÖ FETCH DONE: ${(fetchEnd - fetchStart).toFixed(0)}ms`, 'log-success');
                        
                        if (!res.ok) throw new Error(`API Error ${res.status}`);
                        
                        const parseStart = performance.now();
                        const data = await res.json();
                        
                        // Reconstruct data if optimized format
                        if (data.dates) {
                            const dates = data.dates;
                            data.candles = dates.map((d, i) => ({
                                time: d,
                                open: data.opens[i], high: data.highs[i], low: data.lows[i], close: data.closes[i]
                            }));
                            
                            data.ma = data.ma.map(line => line.map((v, i) => ({ time: dates[i], value: v })));
                            data.rsi = data.rsi.map(line => line.map((v, i) => ({ time: dates[i], value: v })));
                            
                            data.kd.k = data.kd.k.map((v, i) => ({ time: dates[i], value: v }));
                            data.kd.d = data.kd.d.map((v, i) => ({ time: dates[i], value: v }));
                            
                            data.bias = data.bias.map(line => line.map((v, i) => ({ time: dates[i], value: v })));
                            
                            data.macd.dif = data.macd.dif.map((v, i) => ({ time: dates[i], value: v }));
                            data.macd.dea = data.macd.dea.map((v, i) => ({ time: dates[i], value: v }));
                            data.macd.histogram = data.macd.histogram.map((v, i) => ({ 
                                time: dates[i], value: v, color: v >= 0 ? '#26A69A' : '#EF5350'
                            }));
                        }
                        
                        addLog(`üìä JSON: candles=${data.candles?.length || 0}`);
                        
                        const renderStart = performance.now();
                        
                        // --- Main Chart: Candlesticks + MA ---
                        candleSeries.setData(data.candles);
                        
                        // Initialize current candle with the last one
                        if (data.candles.length > 0) {
                            const lastCandle = data.candles[data.candles.length - 1];
                            currentCandle.value = lastCandle;
                            priceChange.value = lastCandle.close - lastCandle.open;
                            priceChangePercent.value = (priceChange.value / lastCandle.open) * 100;
                        }
                        
                        maLines.forEach(l => mainChart.removeSeries(l));
                        maLines = [];
                        data.ma.forEach((m, i) => {
                            if(m.length) {
                                const l = mainChart.addLineSeries({ color: MA_COLORS[i], lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                                l.setData(m);
                                maLines.push(l);
                            }
                        });
                        
                        const mas = [];
                        maLines.forEach((l, i) => {
                            if (data.ma[i]?.length > 0) {
                                const lastMA = data.ma[i][data.ma[i].length - 1];
                                mas.push({ period: MA_PERIODS[i], value: lastMA.value });
                            }
                        });
                        currentMAs.value = mas;
                        
                        // --- RSI Chart ---
                        rsiLines.forEach(l => rsiChart.removeSeries(l));
                        rsiLines = [];
                        const rsiColors = ['#FF6B6B', '#4ECDC4'];
                        data.rsi.forEach((r, i) => {
                            if(r.length) {
                                const l = rsiChart.addLineSeries({ color: rsiColors[i], lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                                l.setData(r);
                                rsiLines.push(l);
                            }
                        });
                        
                        // --- KD Chart ---
                        if (kLine) kdChart.removeSeries(kLine);
                        if (dLine) kdChart.removeSeries(dLine);
                        kLine = kdChart.addLineSeries({ color: '#FFEB3B', lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                        dLine = kdChart.addLineSeries({ color: '#2196F3', lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                        kLine.setData(data.kd.k);
                        dLine.setData(data.kd.d);
                        
                        // --- BIAS Chart (‰∏âÊ¢ùÁ∑ö: BIAS1=117, BIASAV1=17, BIASAV2=45) ---
                        biasLines.forEach(l => biasChart.removeSeries(l));
                        biasLines = [];
                        const biasColors = ['#E91E63', '#00BCD4', '#FFEB3B'];  // Á≤âÁ¥Ö„ÄÅÈùíËâ≤„ÄÅÈªÉËâ≤
                        data.bias.forEach((b, i) => {
                            if(b.length) {
                                const l = biasChart.addLineSeries({ color: biasColors[i], lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                                l.setData(b);
                                biasLines.push(l);
                            }
                        });
                        
                        // --- MACD Chart ---
                        if (difLine) macdChart.removeSeries(difLine);
                        if (deaLine) macdChart.removeSeries(deaLine);
                        if (histSeries) macdChart.removeSeries(histSeries);
                        
                        difLine = macdChart.addLineSeries({ color: '#FFEB3B', lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                        deaLine = macdChart.addLineSeries({ color: '#2196F3', lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                        histSeries = macdChart.addHistogramSeries({ priceLineVisible: false, lastValueVisible: false });
                        
                        difLine.setData(data.macd.dif);
                        deaLine.setData(data.macd.dea);
                        // Force Taiwan Style colors in frontend to override cache
                        histSeries.setData(data.macd.histogram.map(d => ({
                            time: d.time,
                            value: d.value,
                            color: (d.value >= 0) ? '#EF5350' : '#26A69A'
                        })));
                        
                        addLog(`üé® RENDER: ${(performance.now() - renderStart).toFixed(0)}ms`, 'log-success');
                        
                        // Debug Memory if available
                        if (performance.memory) {
                            const mem = performance.memory;
                            addLog(`üíæ MEM: ${(mem.usedJSHeapSize / 1048576).toFixed(1)}MB / ${(mem.jsHeapSizeLimit / 1048576).toFixed(1)}MB`);
                        }
                        mainChart.timeScale().fitContent();
                        addLog(`‚úÖ DONE: Total ${(performance.now() - fetchStart).toFixed(0)}ms`, 'log-success');
                    } catch (e) { 
                        if (e.name === 'AbortError') {
                            addLog(`üö´ ABORTED: ${stock.symbol}`, 'log-warn');
                            return;
                        }
                        addLog(`‚ùå ERROR: ${e.message}`, 'log-error');
                        error.value = e.message;
                    } finally {
                        if (!signal.aborted) {
                            loading.value = false;
                            addLog(`üèÅ Loading=false`);
                        } else {
                            addLog(`‚è≠Ô∏è Skip loading=false (aborted)`, 'log-warn');
                        }
                    }
                };

                // Debounce helper
                const debounce = (fn, delay) => {
                    let timeout;
                    return (...args) => {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => fn(...args), delay);
                    };
                };

                // Create a debounced version of loadStockData
                const _debouncedLoad = debounce((s) => {
                    // Á¢∫‰øùÂè™Âü∑Ë°åÊúÄÂæå‰∏ÄÊ¨°Ë´ãÊ±Ç
                    if (currentStock.value.symbol === s.symbol) {
                        addLog(`üöÄ Executing debounced load for ${s.symbol}`, 'log-success');
                        loadStockData(s);
                    } else {
                        addLog(`üö´ Skipping stale debounced load for ${s.symbol} (current=${currentStock.value.symbol})`, 'log-warn');
                    }
                }, 300);

                const selectStock = (s) => { 
                    addLog(`üëÜ CLICK: ${s.symbol}`, 'log-success');
                    currentStock.value = s; 
                    
                    if (loading.value) {
                        addLog(`‚è≥ Loading busy, debouncing ${s.symbol}...`, 'log-warn');
                        _debouncedLoad(s);
                    } else {
                        loadStockData(s);
                    }
                };

                onMounted(() => { 
                    nextTick(() => {
                        initCharts(); 
                        selectStock(currentStock.value); 
                    });
                });

                return { 
                    isSidebarOpen, currentMarket, currentStock, filteredStocks, selectStock, 
                    chartsScrollContainer, mainChartContainer, rsiChartContainer, kdChartContainer, biasChartContainer, macdChartContainer,
                    loading, error, showDebug, debugLogs, debugPanel,
                    currentCandle, currentMAs, priceChange, priceChangePercent, formatVolume,
                    maColors: MA_COLORS, maPeriods: MA_PERIODS
                };
            }
        }).mount('#app');
    </script>
</body>
</html>