<!DOCTYPE html>
<html lang="zh-TW" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StockView Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { background-color: #1a1a1a; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; }
        .loader { 
            border: 3px solid #333; 
            border-top: 3px solid #3498db; 
            border-radius: 50%; 
            width: 24px; 
            height: 24px; 
            min-width: 24px;
            min-height: 24px;
            flex-shrink: 0;
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        [v-cloak] { display: none; }
        .stock-item.active { background-color: #2563eb; color: white; }
        .chart-section { border-top: 1px solid #2a2e39; }
        .chart-label { 
            position: absolute; 
            left: 8px; 
            top: 4px; 
            z-index: 10; 
            font-size: 11px; 
            color: #888; 
            background: rgba(19, 23, 34, 0.8);
            padding: 2px 6px;
            border-radius: 3px;
        }
        .debug-panel {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 400px;
            max-height: 200px;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            z-index: 9999;
            border-top: 1px solid #333;
            border-left: 1px solid #333;
        }
        .debug-panel .log-entry { margin: 2px 0; }
        .debug-panel .log-error { color: #f66; }
        .debug-panel .log-warn { color: #ff0; }
        .debug-panel .log-success { color: #0f0; }
        .debug-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 10000;
            background: #333;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
    </style>
</head>
<body class="h-screen w-screen flex">
    <div id="app" class="flex w-full h-full">
        <!-- Sidebar -->
        <div :class="['bg-neutral-900 border-r border-neutral-800 flex flex-col z-20 h-full flex-shrink-0', isSidebarOpen ? 'w-80' : 'w-0 overflow-hidden']">
            <div class="p-4 border-b border-neutral-800"><h1 class="text-xl font-bold text-blue-400">StockView</h1></div>
            <div class="flex border-b border-neutral-800">
                <button @click="currentMarket = 'TW'" :class="['flex-1 py-3', currentMarket === 'TW' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-400']">TW Âè∞ËÇ°</button>
                <button @click="currentMarket = 'US'" :class="['flex-1 py-3', currentMarket === 'US' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-400']">US ÁæéËÇ°</button>
            </div>
            <div class="flex-1 overflow-y-auto">
                <div v-for="stock in filteredStocks" :key="stock.symbol" @click="selectStock(stock)" :class="['p-3 mx-2 mb-1 rounded cursor-pointer flex justify-between', currentStock?.symbol === stock.symbol ? 'stock-item active' : 'hover:bg-neutral-800 text-gray-300']">
                    <div><div class="font-bold text-sm">{{ stock.symbol }}</div><div class="text-xs opacity-70">{{ stock.name }}</div></div>
                </div>
            </div>
        </div>
        <!-- Chart Area -->
        <div class="flex-1 flex flex-col h-full relative overflow-hidden" style="background-color: #0a0e17;">
            <!-- DEBUG: Always visible status -->
            <div style="position: absolute; top: 0; left: 0; right: 0; background: red; color: white; z-index: 99999; padding: 10px;">
                DEBUG: Vue is running | Stock: {{ currentStock?.symbol || 'NONE' }} | Market: {{ currentMarket }}
            </div>
            
            <!-- New Header - Yuanta Style -->
            <div class="border-b px-4 py-3 flex-shrink-0" style="background-color: #1a2332; border-color: #2a3a4a;">
                <!-- Top Row: Stock Name & Price -->
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-3">
                        <button @click="isSidebarOpen = !isSidebarOpen" class="text-gray-400 hover:text-white">
                            <i class="fas fa-bars text-lg"></i>
                        </button>
                        <div v-if="currentStock">
                            <div class="flex items-center gap-2">
                                <span class="text-white text-xl font-bold">{{ currentStock.name }}</span>
                                <span class="bg-purple-600 text-white text-xs px-2 py-0.5 rounded">Â∏Ç</span>
                                <span class="text-gray-400 text-lg">{{ currentStock.symbol }}</span>
                            </div>
                        </div>
                    </div>
                    <div v-if="currentCandle" class="text-right">
                        <div class="text-3xl font-bold" :class="priceChange >= 0 ? 'text-red-500' : 'text-green-500'">
                            {{ currentCandle.close.toFixed(2) }}
                        </div>
                        <div class="flex items-center justify-end gap-2 text-sm">
                            <span :class="priceChange >= 0 ? 'text-red-500' : 'text-green-500'">
                                <i v-if="priceChange >= 0" class="fas fa-caret-up"></i>
                                <i v-else class="fas fa-caret-down"></i>
                                {{ Math.abs(priceChange).toFixed(2) }}
                            </span>
                            <span :class="priceChange >= 0 ? 'text-red-500' : 'text-green-500'">
                                {{ priceChangePercent.toFixed(2) }}%
                            </span>
                        </div>
                    </div>
                </div>
                
                <!-- Info Dashboard - OHLCV -->
                <div v-if="currentCandle" class="rounded-lg p-3 mt-2" style="background-color: #0f1419;">
                    <div class="grid grid-cols-6 gap-4 text-center">
                        <div>
                            <div class="text-gray-500 text-xs mb-1">Êó•Êúü</div>
                            <div class="text-white text-sm">{{ currentCandle.time }}</div>
                        </div>
                        <div>
                            <div class="text-gray-500 text-xs mb-1">Èñã</div>
                            <div class="text-red-400 text-sm font-mono">{{ currentCandle.open.toFixed(2) }}</div>
                        </div>
                        <div>
                            <div class="text-gray-500 text-xs mb-1">È´ò</div>
                            <div class="text-red-400 text-sm font-mono">{{ currentCandle.high.toFixed(2) }}</div>
                        </div>
                        <div>
                            <div class="text-gray-500 text-xs mb-1">‰Ωé</div>
                            <div class="text-red-400 text-sm font-mono">{{ currentCandle.low.toFixed(2) }}</div>
                        </div>
                        <div>
                            <div class="text-gray-500 text-xs mb-1">Êî∂</div>
                            <div :class="currentCandle.close >= currentCandle.open ? 'text-red-400' : 'text-green-400'" class="text-sm font-mono font-bold">
                                {{ currentCandle.close.toFixed(2) }}
                            </div>
                        </div>
                        <div>
                            <div class="text-gray-500 text-xs mb-1">Èáè</div>
                            <div class="text-yellow-400 text-sm font-mono">{{ formatVolume(currentCandle.volume) }}</div>
                        </div>
                    </div>
                </div>
                
                <!-- MA Values Row -->
                <div v-if="currentMAs.length > 0" class="flex flex-wrap gap-3 mt-2 px-2">
                    <div v-for="(ma, i) in currentMAs" :key="i" class="flex items-center gap-1 text-xs">
                        <span :style="{ color: __MA_COLORS__[i] }">MA{{ __MA_PERIODS__[i] }}</span>
                        <span class="text-white font-mono">{{ ma.value?.toFixed(2) || '--' }}</span>
                    </div>
                </div>
            </div>
            
            <!-- Loading Indicator -->
            <div v-if="loading" class="absolute top-20 right-4 z-50">
                <div class="loader"></div>
            </div>
            
            <!-- Charts Container (Scrollable) -->
            <div class="flex-1 overflow-y-auto" ref="chartsScrollContainer" style="background-color: #0a0e17;">
                <!-- Main Candlestick Chart -->
                <div class="relative" style="height: 50%;">
                    <div ref="mainChartContainer" class="absolute inset-0"></div>
                </div>
                <!-- RSI Chart -->
                <div class="relative border-t" style="height: 12.5%; border-color: #1a2332;">
                    <div ref="rsiChartContainer" class="absolute inset-0"></div>
                </div>
                <!-- KD Chart -->
                <div class="relative border-t" style="height: 12.5%; border-color: #1a2332;">
                    <div ref="kdChartContainer" class="absolute inset-0"></div>
                </div>
                <!-- BIAS Chart -->
                <div class="relative border-t" style="height: 12.5%; border-color: #1a2332;">
                    <div ref="biasChartContainer" class="absolute inset-0"></div>
                </div>
                <!-- MACD Chart -->
                <div class="relative border-t" style="height: 12.5%; border-color: #1a2332;">
                    <div ref="macdChartContainer" class="absolute inset-0"></div>
                </div>
            </div>
            <!-- Error Overlay -->
            <div v-if="error" class="absolute inset-0 flex items-center justify-center bg-black/80 text-red-400 z-50">{{ error }}</div>
        </div>
        <!-- Debug Panel -->
        <button class="debug-toggle" @click="showDebug = !showDebug">{{ showDebug ? 'Èö±Ëóè' : 'üìã' }} Log</button>
        <div v-if="showDebug" class="debug-panel" ref="debugPanel">
            <div v-for="(log, i) in debugLogs" :key="i" :class="['log-entry', log.type]">
                {{ log.time }} {{ log.msg }}
            </div>
        </div>
    </div>
    <script>
        console.log('DEBUG: Script tag found, Vue available?', typeof Vue);
        const { createApp, ref, computed, onMounted, nextTick } = Vue;
        console.log('DEBUG: Destructuring Vue OK');
        createApp({
            setup() {
                console.log('DEBUG: Vue setup() started');
                const isSidebarOpen = ref(window.innerWidth > 768);
                const currentMarket = ref('TW');
                const currentStock = ref(__STOCK_LIST__[0]);
                const loading = ref(false);
                const error = ref(null);
                const showDebug = ref(false);
                const debugLogs = ref([]);
                const debugPanel = ref(null);
                
                // Yuanta-style new reactive variables
                const currentCandle = ref(null);
                const currentMAs = ref([]);
                const priceChange = ref(0);
                const priceChangePercent = ref(0);
                
                // Format volume (convert to K/M)
                const formatVolume = (vol) => {
                    if (!vol) return '--';
                    if (vol >= 1000000) return (vol / 1000000).toFixed(2) + 'M';
                    if (vol >= 1000) return (vol / 1000).toFixed(0) + 'K';
                    return vol.toString();
                };
                
                const addLog = (msg, type = '') => {
                    const now = new Date();
                    const time = now.toLocaleTimeString('zh-TW', {hour12: false}) + '.' + String(now.getMilliseconds()).padStart(3, '0');
                    debugLogs.value.push({ time, msg, type });
                    if (debugLogs.value.length > 50) debugLogs.value.shift();
                    // Auto scroll
                    nextTick(() => {
                        if (debugPanel.value) debugPanel.value.scrollTop = debugPanel.value.scrollHeight;
                    });
                    console.log(`[${time}] ${msg}`);
                };
                
                // Chart containers
                const chartsScrollContainer = ref(null);
                const mainChartContainer = ref(null);
                const rsiChartContainer = ref(null);
                const kdChartContainer = ref(null);
                const biasChartContainer = ref(null);
                const macdChartContainer = ref(null);
                
                // Chart instances
                let mainChart = null, candleSeries = null, maLines = [];
                let rsiChart = null, rsiLines = [];
                let kdChart = null, kLine = null, dLine = null;
                let biasChart = null, biasLines = [];
                let macdChart = null, difLine = null, deaLine = null, histSeries = null;
                
                let abortController = null;

                const filteredStocks = computed(() => __STOCK_LIST__.filter(s => s.market === currentMarket.value));

                const chartOptions = (container) => ({
                    layout: { background: { type: 'solid', color: '#131722' }, textColor: '#d1d4dc' },
                    grid: { vertLines: { color: '#2B2B43' }, horzLines: { color: '#2B2B43' } },
                    timeScale: { borderColor: '#485c7b', timeVisible: true, visible: true },
                    rightPriceScale: { borderColor: '#485c7b' },
                    crosshair: { mode: LightweightCharts.CrosshairMode.Normal }
                });

                const initCharts = () => {
                    // Main chart with candlesticks
                    mainChart = LightweightCharts.createChart(mainChartContainer.value, chartOptions());
                    candleSeries = mainChart.addCandlestickSeries();
                    
                    // RSI chart
                    rsiChart = LightweightCharts.createChart(rsiChartContainer.value, {
                        ...chartOptions(),
                        rightPriceScale: { scaleMargins: { top: 0.1, bottom: 0.1 } }
                    });
                    
                    // KD chart
                    kdChart = LightweightCharts.createChart(kdChartContainer.value, {
                        ...chartOptions(),
                        rightPriceScale: { scaleMargins: { top: 0.1, bottom: 0.1 } }
                    });
                    
                    // BIAS chart
                    biasChart = LightweightCharts.createChart(biasChartContainer.value, {
                        ...chartOptions(),
                        rightPriceScale: { scaleMargins: { top: 0.2, bottom: 0.2 } }
                    });
                    
                    // MACD chart
                    macdChart = LightweightCharts.createChart(macdChartContainer.value, {
                        ...chartOptions(),
                        rightPriceScale: { scaleMargins: { top: 0.2, bottom: 0.2 } }
                    });
                    
                    // Crosshair Move Handler - Yuanta Style
                    mainChart.subscribeCrosshairMove(param => {
                        if (!param.time) {
                            return;
                        }
                        
                        const candleData = param.seriesData.get(candleSeries);
                        if (candleData) {
                            currentCandle.value = candleData;
                            priceChange.value = candleData.close - candleData.open;
                            priceChangePercent.value = (priceChange.value / candleData.open) * 100;
                            
                            // Update MA values
                            const mas = [];
                            maLines.forEach((line, i) => {
                                const val = param.seriesData.get(line);
                                if (val !== undefined) {
                                    mas.push({ period: __MA_PERIODS__[i], value: val.value });
                                }
                            });
                            currentMAs.value = mas;
                        }
                    });
                    
                    // Sync all charts' time scales
                    const charts = [mainChart, rsiChart, kdChart, biasChart, macdChart];
                    charts.forEach(chart => {
                        chart.timeScale().subscribeVisibleLogicalRangeChange(range => {
                            if (range) {
                                charts.forEach(c => {
                                    if (c !== chart) {
                                        c.timeScale().setVisibleLogicalRange(range);
                                    }
                                });
                            }
                        });
                    });
                    
                    // Resize observer
                    const resizeObserver = new ResizeObserver(() => {
                        [
                            [mainChartContainer, mainChart],
                            [rsiChartContainer, rsiChart],
                            [kdChartContainer, kdChart],
                            [biasChartContainer, biasChart],
                            [macdChartContainer, macdChart]
                        ].forEach(([container, chart]) => {
                            if (container.value && chart) {
                                chart.applyOptions({ 
                                    width: container.value.clientWidth, 
                                    height: container.value.clientHeight 
                                });
                            }
                        });
                    });
                    
                    [mainChartContainer, rsiChartContainer, kdChartContainer, biasChartContainer, macdChartContainer]
                        .forEach(c => { if (c.value) resizeObserver.observe(c.value); });
                };

                const loadStockData = async (stock) => {
                    const requestId = Date.now();
                    addLog(`üîµ SELECT: ${stock.symbol}`, 'log-success');
                    
                    if (abortController) {
                        addLog(`‚ö†Ô∏è Aborting previous request`, 'log-warn');
                        abortController.abort();
                    }
                    abortController = new AbortController();
                    const signal = abortController.signal;

                    loading.value = true; error.value = null;
                    const fetchStart = performance.now();
                    
                    try {
                        addLog(`üì° FETCH: /api/stock/${stock.symbol}`);
                        const res = await fetch(`/api/stock/${stock.symbol}`, { signal });
                        const fetchEnd = performance.now();
                        addLog(`‚úÖ FETCH: ${(fetchEnd - fetchStart).toFixed(0)}ms`, 'log-success');
                        
                        if (!res.ok) throw new Error("API Error");
                        
                        const parseStart = performance.now();
                        const data = await res.json();
                        
                        // Reconstruct data if optimized format
                        if (data.dates) {
                            const dates = data.dates;
                            data.candles = dates.map((d, i) => ({
                                time: d,
                                open: data.opens[i], high: data.highs[i], low: data.lows[i], close: data.closes[i]
                            }));
                            
                            data.ma = data.ma.map(line => line.map((v, i) => ({ time: dates[i], value: v })));
                            data.rsi = data.rsi.map(line => line.map((v, i) => ({ time: dates[i], value: v })));
                            
                            data.kd.k = data.kd.k.map((v, i) => ({ time: dates[i], value: v }));
                            data.kd.d = data.kd.d.map((v, i) => ({ time: dates[i], value: v }));
                            
                            data.bias = data.bias.map(line => line.map((v, i) => ({ time: dates[i], value: v })));
                            
                            data.macd.dif = data.macd.dif.map((v, i) => ({ time: dates[i], value: v }));
                            data.macd.dea = data.macd.dea.map((v, i) => ({ time: dates[i], value: v }));
                            data.macd.histogram = data.macd.histogram.map((v, i) => ({ 
                                time: dates[i], value: v, color: v >= 0 ? '#26A69A' : '#EF5350'
                            }));
                        }
                        
                        addLog(`üìä JSON: candles=${data.candles?.length || 0}`);
                        
                        const renderStart = performance.now();
                        
                        // --- Main Chart: Candlesticks + MA ---
                        candleSeries.setData(data.candles);
                        
                        // Initialize current candle with the last one
                        if (data.candles.length > 0) {
                            const lastCandle = data.candles[data.candles.length - 1];
                            currentCandle.value = lastCandle;
                            priceChange.value = lastCandle.close - lastCandle.open;
                            priceChangePercent.value = (priceChange.value / lastCandle.open) * 100;
                        }
                        
                        maLines.forEach(l => mainChart.removeSeries(l));
                        maLines = [];
                        data.ma.forEach((m, i) => {
                            if(m.length) {
                                const l = mainChart.addLineSeries({ color: __MA_COLORS__[i], lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                                l.setData(m);
                                maLines.push(l);
                            }
                        });
                        
                        const mas = [];
                        maLines.forEach((l, i) => {
                            if (data.ma[i]?.length > 0) {
                                const lastMA = data.ma[i][data.ma[i].length - 1];
                                mas.push({ period: __MA_PERIODS__[i], value: lastMA.value });
                            }
                        });
                        currentMAs.value = mas;
                        
                        // --- RSI Chart ---
                        rsiLines.forEach(l => rsiChart.removeSeries(l));
                        rsiLines = [];
                        const rsiColors = ['#FF6B6B', '#4ECDC4'];
                        data.rsi.forEach((r, i) => {
                            if(r.length) {
                                const l = rsiChart.addLineSeries({ color: rsiColors[i], lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                                l.setData(r);
                                rsiLines.push(l);
                            }
                        });
                        
                        // --- KD Chart ---
                        if (kLine) kdChart.removeSeries(kLine);
                        if (dLine) kdChart.removeSeries(dLine);
                        kLine = kdChart.addLineSeries({ color: '#FFEB3B', lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                        dLine = kdChart.addLineSeries({ color: '#2196F3', lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                        kLine.setData(data.kd.k);
                        dLine.setData(data.kd.d);
                        
                        // --- BIAS Chart (‰∏âÊ¢ùÁ∑ö: BIAS1=117, BIASAV1=17, BIASAV2=45) ---
                        biasLines.forEach(l => biasChart.removeSeries(l));
                        biasLines = [];
                        const biasColors = ['#E91E63', '#00BCD4', '#FFEB3B'];  // Á≤âÁ¥Ö„ÄÅÈùíËâ≤„ÄÅÈªÉËâ≤
                        data.bias.forEach((b, i) => {
                            if(b.length) {
                                const l = biasChart.addLineSeries({ color: biasColors[i], lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                                l.setData(b);
                                biasLines.push(l);
                            }
                        });
                        
                        // --- MACD Chart ---
                        if (difLine) macdChart.removeSeries(difLine);
                        if (deaLine) macdChart.removeSeries(deaLine);
                        if (histSeries) macdChart.removeSeries(histSeries);
                        
                        difLine = macdChart.addLineSeries({ color: '#FFEB3B', lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                        deaLine = macdChart.addLineSeries({ color: '#2196F3', lineWidth: 1, lastValueVisible: false, priceLineVisible: false });
                        histSeries = macdChart.addHistogramSeries({ priceLineVisible: false, lastValueVisible: false });
                        
                        difLine.setData(data.macd.dif);
                        deaLine.setData(data.macd.dea);
                        histSeries.setData(data.macd.histogram);
                        
                        addLog(`üé® RENDER: ${(performance.now() - renderStart).toFixed(0)}ms`, 'log-success');
                        mainChart.timeScale().fitContent();
                        addLog(`‚úÖ DONE: Total ${(performance.now() - fetchStart).toFixed(0)}ms`, 'log-success');
                    } catch (e) { 
                        if (e.name === 'AbortError') {
                            addLog(`üö´ ABORTED: ${stock.symbol}`, 'log-warn');
                            return;
                        }
                        addLog(`‚ùå ERROR: ${e.message}`, 'log-error');
                        error.value = e.message;
                    } finally {
                        if (!signal.aborted) {
                            loading.value = false;
                            addLog(`üèÅ Loading=false`);
                        } else {
                            addLog(`‚è≠Ô∏è Skip loading=false (aborted)`, 'log-warn');
                        }
                    }
                };

                // Debounce helper
                const debounce = (fn, delay) => {
                    let timeout;
                    return (...args) => {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => fn(...args), delay);
                    };
                };

                // Create a debounced version of loadStockData
                const _debouncedLoad = debounce((s) => {
                    // Á¢∫‰øùÂè™Âü∑Ë°åÊúÄÂæå‰∏ÄÊ¨°Ë´ãÊ±Ç
                    if (currentStock.value.symbol === s.symbol) {
                        addLog(`üöÄ Executing debounced load for ${s.symbol}`, 'log-success');
                        loadStockData(s);
                    } else {
                        addLog(`üö´ Skipping stale debounced load for ${s.symbol} (current=${currentStock.value.symbol})`, 'log-warn');
                    }
                }, 300);

                const selectStock = (s) => { 
                    addLog(`üëÜ CLICK: ${s.symbol}`, 'log-success');
                    currentStock.value = s; 
                    
                    if (loading.value) {
                        addLog(`‚è≥ Loading busy, debouncing ${s.symbol}...`, 'log-warn');
                        _debouncedLoad(s);
                    } else {
                        loadStockData(s);
                    }
                };

                onMounted(() => { 
                    nextTick(() => {
                        initCharts(); 
                        selectStock(currentStock.value); 
                    });
                });

                return { 
                    isSidebarOpen, currentMarket, currentStock, filteredStocks, selectStock, 
                    chartsScrollContainer, mainChartContainer, rsiChartContainer, kdChartContainer, biasChartContainer, macdChartContainer,
                    loading, error, showDebug, debugLogs, debugPanel,
                    currentCandle, currentMAs, priceChange, priceChangePercent, formatVolume
                };
            }
        }).mount('#app');
    </script>
</body>
</html>